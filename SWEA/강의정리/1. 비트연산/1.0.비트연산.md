# 1.0. 비트연산

### 파일의 내용을 표준 입력으로 읽어오는 방법

```cpp
freopen("sample_input.txt","r",stdin);
```

### 비트연산자

| & | 비트단위로 AND 연산을 한다. |
| --- | --- |
| | | 비트단위로 OR 연산을 한다. |
| ^ | 비트단위로 XOR 연산을 한다. (같으면 0 다르면 1) |
| ~ | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. |
| << | 피연산자의 비트 열을 왼쪽으로 이동시킨다. |
| >> | 피연산자의 비트 열을 오른쪽으로 이동시킨다. |

1) 1 << n

- $2^n$의 값을 갖는다.
- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- Power set (모든 부분 집합)
    - 공집합과 자기 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.

2) i & (1 << j)

- 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.

### 2의 보수

⇒  `음의 n 2진수` = ~`양의 n 2진수` + 1

### Bit를 이용한 부분 집합 생성

- 원소 수에 해당되는 N개의 비트를 이용한다.
- n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미한다.

| 10진수 | 이진수 | {A,B,C,D} |
| --- | --- | --- |
| 0 | 0000 | {} |
| 1 | 0001 | {A} |
| 2 | 0010 | {B} |
| 3 | 0011 | {A,B} |
| 4 | 0100 | {C} |
| 5 | 0101 | {A,C} |
| 6 | 0110 | {B,C} |
| 7 | 0111 | {A,B,C} |
| 8 | 1000 | {D} |
| 9 | 1001 | {A,D} |
| 10 | 1010 | {B,D} |
| 11 | 1011 | {A,B,D} |
| 12 | 1100 | {C,D} |
| 13 | 1101 | {A,C,D} |
| 14 | 1110 | {B,C,D} |
| 15 | 1111 | {A,B,C,D} |

```cpp
//원소는 {A,B,C,D}라고 가정! alpha[] = {A,B,C,D}; 
//n은 원소의 개수. n=4
for(int i=0; i<(1<<n); ++i){ //(1<<n)에서 n=4니까 16. i를 0부터 15까지 돌리기
	cout << "{";
	for(int j=0; j<n;++j){
		if(i & (1 << j)) cout << alpha[j];
	cout << "}\n"; 
}
```

- i & (1 << j) 계산법
    
    예시) i가 `0011` 일 때, 
    
    - **j가 1일 경우**
        
        (1 << j) = (1 << 1) = 0010
        
        i & (1 << j) = 0011 & 0010 = 0010(2) = 2(10)
        
        ⇒ `true`
        
    - **j가 3일 경우**
        
        (1 << j) = (1 << 3) = 1000
        
        i & (1 << j) = 0011 & 1000 = 0000(2) = 0(10)
        
        ⇒ `false`
        

### 실수의 표현

- 컴퓨터는 실수를 `근사적으로` 표현한다.
- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.
- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
    
    → 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
    
    - 1001.0011 → 1.0010011 * $2^3$

(Tip💡)

$d =sqrt((dx)^2 + (dy)^2)$ → 소수가 나오고 오차 발생할 수 있음

이를, $d^2 = (dx)^2 + (dy)^2$  로 계산하는 것이 더 좋다.
